package main

import (
    "os"
    tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
    //"fmt"
    //"strings"
)

func log() {
    // Давайте рассмотрим каждое обновление, которое мы получаем от Telegram.
    for update := range updates {
        
        // Telegram может отправлять множество типов обновлений в зависимости от того, 
        // чем занимается ваш бот. Пока мы хотим просмотреть только сообщения, чтобы 
        // отменить любые другие обновления.
        if update.Message == nil {
            continue
        }

        // Теперь, когда мы знаем, что получили новое сообщение, мы можем составить ответ! 
        // Мы возьмем идентификатор чата и текст из входящего сообщения и используем его 
        // для создания нового сообщения.
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)

        // Мы также скажем, что это сообщение является ответом на предыдущее сообщение. 
        // Для любых других спецификаций, кроме идентификатора чата или текста, 
        // вам нужно будет задать поля в `MessageConfig`.
        msg.ReplyToMessageID = update.Message.MessageID

        // Хорошо, мы отправляем наше сообщение! Нас не волнует сообщение, 
        // которое мы только что отправили, поэтому мы его удалим.
        if _, err := bot.Send(msg); err != nil {
            // Обратите внимание, что паника - плохой способ обработки ошибок. 
            // В Telegram могут быть перебои в обслуживании или сетевые ошибки, вам следует 
            // повторить попытку отправки сообщений или более корректно обрабатывать сбои.
            panic(err)
        }
    }
}

// export TELEGRAM_APITOKEN=...(number from telegram bot)
func main() {
    bot, err := tgbotapi.NewBotAPI(os.Getenv("TELEGRAM_APITOKEN"))
    if err != nil {
        panic(err)
    }

    bot.Debug = true
    
    // Создайте новую структуру updateConfig со смещением, равным 0. Смещения используются 
    // для того, чтобы убедиться, что Telegram знает, что мы обработали предыдущие значения, 
    // и нам не нужно их повторять.
    updateConfig := tgbotapi.NewUpdate(0)

    // Сообщите Telegram, что мы должны ждать до 30 секунд при каждом запросе обновления. 
    // Таким образом, мы можем получать информацию так же быстро, как и при выполнении 
    // множества частых запросов, без необходимости отправлять почти столько же запросов.
    updateConfig.Timeout = 30

    // Начните опрос Telegram на предмет обновлений.
    updates := bot.GetUpdatesChan(updateConfig)

    // Давайте рассмотрим каждое обновление, которое мы получаем от Telegram.
    /*for update := range updates {
        
        // Telegram может отправлять множество типов обновлений в зависимости от того, 
        // чем занимается ваш бот. Пока мы хотим просмотреть только сообщения, чтобы 
        // отменить любые другие обновления.
        if update.Message == nil {
            continue
        }

        // Теперь, когда мы знаем, что получили новое сообщение, мы можем составить ответ! 
        // Мы возьмем идентификатор чата и текст из входящего сообщения и используем его 
        // для создания нового сообщения.
        msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)

        // Мы также скажем, что это сообщение является ответом на предыдущее сообщение. 
        // Для любых других спецификаций, кроме идентификатора чата или текста, 
        // вам нужно будет задать поля в `MessageConfig`.
        msg.ReplyToMessageID = update.Message.MessageID

        // Хорошо, мы отправляем наше сообщение! Нас не волнует сообщение, 
        // которое мы только что отправили, поэтому мы его удалим.
        if _, err := bot.Send(msg); err != nil {
            // Обратите внимание, что паника - плохой способ обработки ошибок. 
            // В Telegram могут быть перебои в обслуживании или сетевые ошибки, вам следует 
            // повторить попытку отправки сообщений или более корректно обрабатывать сбои.
            panic(err)
        }
    }*/

}
